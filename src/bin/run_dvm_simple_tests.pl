#!/usr/bin/perl
#

#
# Copyright(c)  2018-2019       UT-Battelle, LLC
#                               All rights reserved
#

# Script that launches a set of test until we find the maximum number of nodes where the test succeeds.

use strict;
use warnings "all";

use Getopt::Long;
use File::Basename;
use Cwd qw(cwd);

my $verbose = 0;
my $help = 0;
my $project = undef;
my $queue = undef;
my $nnodes = 4;
my $configlog = "./dvm_simple_config.log";
my $np_per_node = 42;
my $max_nnodes = 4608;
my $np = undef;
my $platform = "summit";
my $resultfile = 0;
my $output_dir = undef;
my $experiment = undef;

my $cmd = undef;
my $rc = 0;
my $done = 0;

GetOptions (
	"project=s"     => \$project,
	"verbose"       => \$verbose,
	"help"          => \$help,
	"queue=s"       => \$queue,
	"platform=s"    => \$platform,
	"resultfile"    => \$resultfile,
	"outputdir=s"   => \$output_dir,
	"experiment=s"  => \$experiment,
);

# Based on where the script is, we figure out the path to all the required packages and scripts
my $topDir = Cwd::abs_path(File::Basename::dirname (__FILE__)) . "/../..";
my $topSrcDir = "$topDir/src";
my $libDir = "$topSrcDir/lib";
my $binDir = "$topSrcDir/bin";
my $etcDir = "$topDir/etc";
my $platformsConfigDir = "$etcDir/platforms";
my $experimentsDir = "$etcDir/experiments";
push (@INC, $libDir);

if ($help)
{
	print "Usage: $0 --outputdir <DIR> --project <LSFPROJECTID> --platform <PLATFORM> --experiment <EXPERIMENT_NAME> [--queue <LSF_QUEUE>] [--resultfile] [--verbose] [--help]\n";
	print "\t--outputdir    Path to the directory where to save temporary files and results.\n";
	print "\t--experiment   Name of the experiment to run (all experiments are defined in $experimentsDir)\n";
	print "\t--project      LSF project ID to be used to submit jobs for testing.\n";
	print "\t--platform     Execution platform's name (all supported platforms are defined in $platformsConfigDir).\n";
	print "\t--queue        LSF queue to use to submit jobs for testing.\n";
	print "\t--resultfile   Use the result file generated by the job rather than the output of the job to determine success.\n";
	print "\t--verbose      Enable the verbose mode.\n";
	print "\t--help         This help message.\n";
	exit 0;
}

die "ERROR: undefined experiment" if (!defined ($experiment));
die "ERROR: undefined project" if (!defined ($project));
die "ERROR: invalid number of nodes" if (!defined ($nnodes) || $nnodes <= 0);
die "ERROR: invalid output directory" if (!defined ($output_dir));

require "Utils/Fmt.pm";
my %VerbosityCfg;
my $refVCfg = \%VerbosityCfg;
$refVCfg = Utils::Fmt::set_verbosity ($refVCfg, $verbose);

# Load the platform configuration file if it exists
require "Utils/ConfParser.pm";
my $platformConfigFile = "$platformsConfigDir/$platform.conf";
if (-e $platformConfigFile)
{
	Utils::Fmt::vlogln ($refVCfg, "Loading configuration from $platformConfigFile");
	my $cfgRef = Utils::ConfParser::load_config ($platformConfigFile);
	die "ERROR: Cannot load the configuration from $platformConfigFile" if (!defined ($cfgRef));
	my %cfg = %$cfgRef;

	$np_per_node = $cfg{'pe_per_node'} if (exists ($cfg{'pe_per_node'}));
	$max_nnodes = $cfg{'max_nnodes'} if (exists ($cfg{'max_nnodes'}));
	$nnodes = $cfg{'min_nnodes'} if (exists ($cfg{'min_nodes'}));

	Utils::Fmt::vlogln ($refVCfg, "Initial configuration for $platform:");
	Utils::Fmt::vlogln ($refVCfg, "NP per node: $np_per_node");
	Utils::Fmt::vlogln ($refVCfg, "Max number of nodes: $max_nnodes");
	Utils::Fmt::vlogln ($refVCfg, "Min number of nodes: $nnodes");
}

sub _get_np ($)
{
	return $nnodes * $np_per_node;
}

my $last_successful_test = undef;

# Do some clean-up
require "Utils/Exec.pm";
$cmd = "cd $output_dir; rm -rf $configlog core.*";
Utils::Exec::run_cmd ($refVCfg, $cmd);

do
{
	# Detecting the creation of core dumps is a way for us to detect silent failures so we can sure the current directory
	# is clean before starting a new test
	$cmd = "cd $output_dir; rm -f core.*";
	Utils::Exec::run_cmd ($refVCfg, $cmd);

	$np = _get_np ($nnodes);
	$cmd = "cd $output_dir; $binDir/run_dvm_simple_test.pl --project $project --configlog $configlog --nnodes $nnodes --np $np --output-dir $output_dir --experiment $experiment";
	$cmd .= " --queue $queue" if (defined ($queue));
	$cmd .= " --verbose" if ($verbose);
	$cmd .= " --resultfile" if ($resultfile);
	$rc = Utils::Exec::run_cmd ($refVCfg, $cmd);

	if ($rc != 0)
	{
		# The test did not pass
		if (!defined ($last_successful_test))
		{
			$nnodes = $nnodes / 2;
			$done = 1 if ($nnodes <= 1);
			Utils::Fmt::vprintln ($refVCfg, "Test failed; launching a test with $nnodes nodes...");
		}
		else
		{
			Utils::Fmt::vprintln ($refVCfg, "Test with $nnodes nodes failed.");
			my $epsilon = ($nnodes - $last_successful_test) / 2;
			if ($epsilon <= 8)
			{
				Utils::Fmt::vprintln ($refVCfg, "New epsilon: $epsilon - Done");
				$done = 1;
			}
			else
			{
				$nnodes = $nnodes - $epsilon;
				Utils::Fmt::vprintln ($refVCfg, "New epsilon: $epsilon - Testing with $nnodes nodes...");
			}
		}
	}
	else
	{
		Utils::Fmt::vprintln ($refVCfg, "Successfully ran test with $nnodes nodes");
		$last_successful_test = $nnodes;

		if ($nnodes != $max_nnodes)
		{
			$nnodes = $nnodes * 2;
			$nnodes = $max_nnodes if ($nnodes > $max_nnodes);
		}
		else
		{
			$done = 1;
		}
	}
} while ($done == 0);

print "Successfully ran DVM with $last_successful_test nodes\n" if (defined $last_successful_test);
print "ERROR: Could run any test successfully" if (!defined $last_successful_test);
